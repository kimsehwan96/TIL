# Dynamodb / NoSQL

## 관게형 데이터 디자인과 NoSQL 의 차이점

관계형 데이터베이스 시스템과 NoSQL 은 서로 다른 장단점을 갖고 있습니다.

RDBMS에서는 데이터를 유연하게 쿼리 할 수 있지만, 쿼리는 상대적으로 비용이 많이 들고 트래픽이 많은 상황에서는 잘 확장되지 않습니다.

NoSQL 에서는 제한된 수의 방법으로 데이터를 효율적으로 쿼리 할 수 있지만, 그 외에는 쿼리 비용이 많이 들고 느릴 수 있습니다. 

RDBMS 에서는 구현 세부 사항이나 성능에 대한 걱정 없이 유연성을 고려하여 설계합니다. 쿼리 최적화는 일반적으로 스키마 설계에 영향을 미치지 않지만 정규화가 중요합니다.

## 모범 사례

### 액세스 패턴에 집중

대부분의 데이터 모델링은 다양한 개체(Entity) 와 연결 방법 (Entity 와의 관계)을 설명하는 ERD 다이어그램으로 시작합니다. 관계형 데이터베이스는 엔티티를 테이블에 넣고 외래키등을 사용해 관계를 지정합니다. 이런 다양한 테이블에 대해서 관계형 데이터베이스는 필요한 형태의 데이터를 반환 할 수 있도록 하는 유연한 쿼리 언어 또한 제공합니다. (Join 등). 

DynamoDB 에서는 테이블을 모델링하기 전에 액세스 패턴에 대해서 생각해야 합니다. NoSQL 데이터베이스는 유연성이 아닌 속도에 중점을 두기때문에, 쿼리에 대한 반환 형태를 생각(데이터 엑세스)하고 데이터를 모델링해야합니다.

이에 따라 테이블을 설계하기 전에 애플리케이션에서 데이터를 읽고 쓰는데 필요한 모든 요구 사항을 문서화 하고, 액세스 패턴에 맞게 테이블을 최적화 할 것 이기 떄문에 애플리케이션의 모든 흐름에 대해서 철저하게 생각해봐야 합니다.

### DynamoDB 에 대한 요청에 맞게 최적화

애플리케이션의 액세스 패턴 요구를 문서화 하고 나면 테이블을 디자인 할 준비가 된 것입니다. 각 액세스 패턴에 대해 DynamoDB 에 대한 요청 수를 최소화 하도록 테이블을 설계합니다. 따라서, RDBMS 에서 강조하던 정규화 같은 부분은 오히려 배재하게 됩니다. 

이 최적화를 위해서는 기본키, 보조 인덱스, 트랜잭션에 대해서 이해해야합니다.

### 관계형 모델에 속지 말기

DynamoDB 를 처음 접하는 사람들은 종종 DynamoDB 에 관계형 모델을 구현하려고 시도하는데, 그렇게하면 DynamoDB 의 대부분의 이점을 잃게 됩니다.

안티패턴은 아래와 같습니다.

#### 정규화

관계형 데이터베이스에서는 데이터를 정규화하여 데이터 중복성과 저장 공간을 줄인 다음 Join 을 사용하여 서로 다른 여러 테이블을 결합하지만, 대규모 조인은 느리고 비용이 많이 듭니다. DynamoDB는 테이블이 커짐에 따라 속도가 느려지기 떄문에 조인을 허용하지 않습니다.

#### 하나의 테이블에 하나의 엔티티

DynamoDB 테이블은 단일 테이블에 다양한 유형의 데이터를 포함하는 경우가 많습니다. 단일 테이블에 A, B, C 라는 엔티티가 존재해도 괜찮습니다.

#### 너무 많은 보조 인덱스

인덱스 과부하 주의


## 기본 키

테이블을 생성 할 때 테이블의 이름 외에도 테이블의 기본 키를 지정해야 합니다. 기본 키는 테이블의 각 항목을 고유하게 식별하기 때문에 두 항목이 동일한 키를 가지면 안됩니다.

DynamoDB 는 총 두가지의 기본 키를 지원합니다. 

### Parition(Hash) Key

파티션 키로 알려진 하나의 속성으로 구성된 단순 기본 키입니다. 

DynamoDB 는 파티션 키의 값을 내부 해시 함수에 대한 입력으로 사용합니다. 해시 함수의 출력은 항목이 저장될 파티션 (DynamoDB 는 내부적으로 데이터를 sharding 함 / 분산 적재) 을 결정합니다. 

파티션 키만 있는 테이블에서는 두 항목이 동일한 파티션 키 값을 가질 수 없습니다. 

### Partition(Hash) Key + Sort(Range) Key

복합 기본키라고 하는 이 유형은 두가지의 속성으로 구성됩니다. 첫 번째 속성은 파티션 키이고 두 번째 속성은 정렬 키 입니다. 

동일한 파티션 키 값을 가진 모든 항목은 정렬(Sort/Range)키 값을 기준으로 정렬된 순서로 함께 저장됩니다. 

파티션 키와 정렬 키가 있는 테이블에서 여러 항목이 동일한 파티션 키 값을 가질 수 있지만, 이런 경우에는 정렬 키 값이 달라야 합니다.

이러한 복합 기본 키는 데이터를 쿼리 할 때 추가적인 유연성을 제공 할 수 있습니다. 

## 파티션 키는 뭘로 설정할까?

파티션 키를 설정 할 때에는 높은 카디널리티를 가지는 속성을 설정하는게 좋습니다. 예를들자면 email, employee_no, customerId 같은 것이 고유한 값을 가지는, 카디널리티가 높은 속성을 지정하는게 좋습니다.

엑세스 패턴을 충족하는 경우 두가지 이상의 속성을 결합한 복합 기본키를 설정해서 사용하면 좋습니다.

예를들어 customerId 와 order_date 이 각각 파티션/정렬 키 인 경우를 고려해볼 수 있습니다.

ref : https://aws.amazon.com/ko/blogs/database/choosing-the-right-dynamodb-partition-key/

ref : https://zuminternet.github.io/DynamoDB/

### 모범 사례

직원, 부서, 고객, 주문 등 여러가지 유형의 데이터를 단일 테이블에 저장하는 경우 기본 키에 각 엔티티를 명확하게 식별하고, 개별 항목에 대한 핵심 작업을 활성화 할 방법이 있는지 확인해야 합니다.

접두사를 사용하여 엔티티 유형을 구분하는것도 방법입니다. 엔티티 유형을 구분하면 충동을 방지하고 쿼리에도 도움이 될 수 있습니다. 예를들어 동일한 테이블에 고객과 직원이 모두 있는 경우, 고객의 기본키는 `CUSTOMER#<CUSTOMERID>` 를 사용 할 수 있고, 직원의 고객 키는 `EMPLOYEE#<EMPLYOEEID>` 같은 형태를 사용 가능합니다.

단일 항목 작업에 집중한 다음, 가능하면 여러 항목 작업을 추가합니다. 기본 키의 경우 단일 항목을 접근하는 GetItem, PutItem, UpdateItem, DeletItem 으로 처리가 가능합니다. 만약 그 외 쿼리 항목이 필요한 경우 보조 인덱스를 사용하는 방법을 고려합니다.



## DynamoDB 데이터 모델링 / 테스트

https://amazon-dynamodb-labs.com/game-player-data/plan-model/step1.html